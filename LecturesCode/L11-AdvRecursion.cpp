/*
Примерна програма за демонстрация на по-сложни рекурсивни задачи към курса УП (2017).
    Ханойски кули
    Бързо степенуване
    Търсене с връщане - има ли път в лабиринт
*/

#include <iostream>
#include <cstdlib>
using namespace std;

/////////////////////////////////////////////
//Решение на задачата с ханойските кули

// Функция за реализиране на самото местене.
void move(int from, int to)
{
    cout << "Премести диск от " << from << " на " << to << endl;
}

// Рекурсивна функция, решаваща задачата
// Получава като аргументи от кой на кой пилон трябва да се премести кулата
// както и броя на дисковете в нея
void hanoiRec(int from, int to, int n)
{
    if (n > 0)
    {
        int middle = 6 - from - to;
        hanoiRec(from, middle, n-1);
        move (from, to);
        hanoiRec(middle, to, n-1);
    }
}

// Фнкция обвивка
void hanoi(int n)
{
    hanoiRec(1, 3, n);
}

/////////////////////////////////////////////

// Функция за бързо степенуване.
double power(double x, unsigned n)
{
    if (n == 0)
        return 1;

    double p2 = power(x, n/2);
    if (n%2 == 1)
        return x * p2 * p2;
    else
        return p2 * p2;
}


//////////////////////////////////////////////////////////////////////////////////////////
//  Решение на задачата за проверка има ли път между
// две клетки в лабиринт представен като матрица от числа.
// Стойност 0 означава проходима клетка, стойност != 0 непроходима.

const int SIZE = 10;            // Максимален размер на матрицата
int lab[SIZE][SIZE] =           // Самата матрица зададена чрез инициализация за удобство
{
    {0, 1, 0, 0, 0, 1, 1, 0, 0, 0},
    {0, 1, 0, 1, 1, 0, 0, 0, 0, 0},
    {0, 1, 1, 1, 1, 0, 1, 0, 1, 0},
    {0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
    {0, 1, 1, 1, 1, 0, 1, 1, 1, 1},
    {1, 0, 1, 1, 0, 0, 1, 0, 0, 0},
    {0, 0, 1, 0, 1, 1, 0, 1, 0, 0},
    {0, 0, 0, 0, 0, 1, 0, 0, 1, 0},
    {0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
    {0, 0, 0, 0, 0, 1, 0, 0, 0, 0}
};

int dx[] = {0,  1,  0, -1};     // Отместване по X
int dy[] = {1,  0, -1,  0};     // Отместване по Y
//  Размер на масива - приложим само когато масива
// е деклариран в същата област на действие (scope)
const int numMoves = sizeof(dx)/sizeof(dx[0]);

//  Глобални координати на целта
// Идеята е да не се подават постоянно като аргументи на рекурсията
int g_endX, g_endY;

bool hasPathRec(int x, int y)
{
    //  Гранични условия:
    // първо успех:
    if (x == g_endX && y == g_endY)
        return true;

    // после неуспешни:
    if (x < 0 || x >= SIZE || y < 0 || y >= SIZE)   // излизаме от границите на масива
        return false;
    if (lab[x][y] != 0)                             // или сме стъпили в непроходима клетка
        return false;

    lab[x][y] = 2;
    // Сега опитваме рекурсивно да намерим път във всички възможни посоки
    bool hasPath = false;
    for (int direction = 0; !hasPath && direction < numMoves; ++direction)
    {
        hasPath = hasPathRec(x + dx[direction], y + dy[direction]);
    }
    return hasPath;
}

bool hasPath(int startX, int startY, int endX, int endY)
{
    g_endX = endX;
    g_endY = endY;
    return hasPathRec(startX, startY);
}


//////////////////////////////////////////////////////////////////////////////////////////
int main()
{
/*
    system("chcp 1251");
    hanoi(10);
*/
/*
    for (int i = 0; i <= 10; ++i)
        cout << power(2, i) << endl;
*/
    cout << boolalpha << hasPath(0, 0, 0, 9) << endl;
    for (int i = 0; i < SIZE; ++i)
    {
        for (int j = 0; j < SIZE; ++j)
        {
            cout << lab[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
